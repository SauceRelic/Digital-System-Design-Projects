library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.math_real.all;

entity lpm_tb is
end entity;

architecture testbench of lpm_tb is
  
  signal A: std_logic_vector(4 downto 0);
  signal B: std_logic_vector(6 downto 0);
  signal AxB: std_logic_vector(11 downto 0);
  signal CLK: std_logic;
  constant t: time := 20 ns;
  
  variable x: unsigned := 0;
  variable y: unsigned := 0;
  
  
  component lpm
  port(
    dataa: in std_logic_vector(4 downto 0);
    datab: in std_logic_vector(6 downto 0);
    result: out std_logic_vector(11 downto 0)
  );
  end component;
  
begin

  DUT: lpm
  port map(
    dataa = A,
    datab => B,
    result => AxB
  );
  
  clock: process
  begin
    CLK <= 0;
    wait for t/2;
    infinite: loop
      CLK <= not(CLK);
      wait for t/2;
    end loop;
  end process;
  
  run: process(CLK)
  begin
    if(rising_edge(CLK)) then
      A <= std_logic_vector(x);
      B <= std_logic_vector(y);
      
      x <= x + 1;
      
      if(x >= 32) then
        x <= 0;
        y <= y + 1;
        
        if(y >= 128) then
          wait;
        end if;
      end if;
    end if;
  end process;

end architecture;